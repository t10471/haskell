VimShellInteractive ghci -no-user-package-db -package-db /root/.ltshs/2.13/x86_64-linux-ghc-7.8.4-packages.conf.d


Summary: given an injective function A x N -> B x N, it is possible to constructively “divide by N” to obtain an injection A -> B, 
要約 A x N -> B x N の単射関数が与えられ時、建設的にNで割り、単射 A -> B を得ることができる
as shown recently by Peter Doyle and Cecil Qiu and expounded by Richard Schwartz. 
ということが最近証明された(名前省略)
Their algorithm is nontrivial to come up with—this had been a longstanding open question—but it’s not too difficult to explain. 
このことは長年の未解決問題であり、彼らのアルゴリズムは簡単には見つけることができないが、説明するのは難しくない
I exhibit some Haskell code implementing the algorithm, and show some examples.
Haskellでアルゴリズムを実装しいくつかの例を示す


Introduction: division by two
導入 2で割る

Suppose someone hands you the following:
誰かが以下のことを示したとしよう

    A Haskell function f :: (A, Bool) -> (B, Bool), where A and B are abstract types 
    Haskellの関数 f 、AとBは抽象型である
    (i.e. their constructors are not exported, and you have no other functions whose types mention A or B).

    A promise that the function f is injective, that is, no two values of (A, Bool) map to the same (B, Bool) value. 
    fは単射であると約束する、それは(A, Bool)は唯一の(B,Bool)に対応するということである。
    (Thus (B, Bool) must contain at least as many inhabitants as (A, Bool).)
    なので、(B,Bool) は少なくとも (A,Bool)と同じ数の要素が含まれるはずである

    A list as :: [A], with a promise that it contains every value of type A exactly once, at a finite position.
    Aのリストは全てのAの型の要素が1回だけ含まれ有限であるとする

    Can you explicitly produce an injective function f' :: A -> B? Moreover, your answer should not depend on the order of elements in as.
    明示的に単射関数f'を生成することは可能でしょうか？ さらに、要素の並び順に依存してはいけません

It really seems like this ought to be possible. After all, if (B, Bool) has at least as many inhabitants as (A, Bool), 
これらは可能なように思え、実際、(B,Bool)が少なくとも(A,Bool)と同じかずの要素を持つならば、
then surely B must have at least as many inhabitants as A. 
確かにBは少なくともAと同じ数の要素を持つべきである
But it is not enough to reason merely that some injection must exist; we have to actually construct one. 
しかし単に単射が存在しているというだけでは不十分である。実際に作成してみなければならない。
This, it turns out, is tricky. As a first attempt, we might try f' a = fst (f (a, True) ).
これは少々トリッキーであるとわかる。最初にf' a = fst (f (a, True)) としてみる
That is certainly a function of type A -> B, but there is no guarantee that it is injective.
これは確かにA -> B型の関数である。しかし、単射という保証はない。
There could be a1, a2 :: A which both map to the same b, that is, one maps to (b, False) and the other to (b, True).
Aにa1とa2があったとして、両方が同じbに対応するかもしれない。つまり、(b, False)と(b, True)に対応するということである
The picture below illustrates such a situation: (a1, True) and (a2, True) both map to b2.
下記の画像は(a1, True)と(a2, True)が両方b2に対応していることを示している
So the function f may be injective overall, but we can’t say much about f restricted to a particular Bool value.
なのでfは単射かもしれないが、fが特定のBoolの値に限定出来るということは言えない

下記の内容の画像
(a1, True)  -> (b2, True)
(a2, False) -> (b1, False)
(a2, True)  -> (b2, False)
(a2, False) -> (b3, True)


The requirement that the answer not depend on the order of as also makes things difficult. 
順序に依存しないという制約のせいで回答を難しくしている
(Over in math-land, depending on a particular ordering of the elements in as would amount to the well-ordering principle, 
数学において特定の要素の順序に依存することを整列原理という
which is equivalent to the axiom of choice, which in turn implies the law of excluded middle
選択公理でもあり、排中律もともなう
—and as we all know, every time someone uses the law of excluded middle, a puppy dies. 
子犬が死んだときに排中律を使うことは知られている
…I feel like I’m in one of those DirecTV commercials. 
DirecTVのCMのように
“Don’t let a puppy die. Ignore the order of elements in as.”)
子犬が死んだらasの要素の順序を無視しなさい
Anyway, making use of the order of values in as, we could do something like the following:
いずれにしても値の順序を利用してことで下記のことが出来る

For each a :: A:
Aのaそれぞれに
    Look at the B values generated by f (a,True) and f (a,False). 
    f (a, True) と f (a, False)によって与えられたBをみつける
        (Note that there might only be one distinct such B value). 
        Bの値が明確でなければいけない
    If neither B value has been used so far, pick the one that corresponds to (a,True), 
    もしBの値が使われていなければ対応する(a, True)に対応するものを取得する
        and add the other one to a queue of available B values.
        そして別のは利用できるBのキューに追加する
    If one is used and one unused, pick the unused one.
    利用しているのとしていないのがあれば利用していないのを取得する
    If both are used, pick the next available B value from the queue.
    両方使用していれば利用可能なBのキューから次を取得する

It is not too hard I couldn’t be bothered to show that this will always successfully result in a total function A -> B, which is injective by construction. 
示すことはそんなに厄介ではない。全てのA -> Bの関数は単射による構造のおかげで常に良い結果をもたらす
(One has to show that there will always be an available B value in the queue when you need it.) 
必要な時にキューの利用可能なBno値は常にある
The only problem is that the particular function we get depends on the order in which we iterate through the A values. 
唯一の問題はAの値を走査するときに順序に依存する特定の関数があることだ
The above example illustrates this as well: 
下記の例はよく示している
if the A values are listed in the order [a1, a2], then we first choose a1 -> b2, and then a2 -> b3. 
もし、[a1,a2]のように並んだAの値があったとき、最初に a1 -> b2を選び次に a2 -> b3を選んだとする
If they are listed in the other order, we end up with a2 -> b2 and a1 -> b1. 
もし別な並び順で並んでいた場合、a2 -> b2 と a1 -> b1 になってしまう
Whichever value comes first “steals” b2, and then the other one takes whatever is left. 
どちらにしても最初に得るのはb2であり他は残りを手にする
We’d like to avoid this sort of dependence on order. 
並び順に依存するのを避けるべきである
That is, we want a well-defined algorithm which will yield a total, injective function A -> B, 
単射関数 A -> B を生成する具合が良いアルゴリズムが欲しい
which is canonical in the sense that the algorithm yields the same function given any permutation of as.
どんな順序のasを与えられても同じ関数を生成する標準のアルゴリズム

It is possible—you might enjoy puzzling over this a bit before reading on!
読みすすめれば、この悩ましいいことに楽しめるだろう


Division by N
Nで割る

The above example is a somewhat special case. 
上記の例は特別なケースである
More generally, let N = {0,..., n-1} denote a canonical finite set of size n, and let A and B be arbitrary sets. 
一般的に N は標準的な有限のサイズnを示す。 そしてAとBは任意の集合である
Then, given an injection f : A x N -> B x N, is it possible to effectively (that is, without excluded middle or the axiom of choice) compute an injection A -> B?
では、単射であるfが与えられたとき、排中律や選択公理なしに効果的にA -> Bを計算できるのでしょうか？

Translating down to the world of numbers representing set cardinalities
基数の集合に代表される数字の世界では
—natural numbers if A and B are finite, or cardinal numbers in general—
一般的にAとBが有限ならば自然数であるか基数である
this just says that if an <= bn then a <= b. 
an <= bn ならば a <= b であるといえる
This statement about numbers is obviously true, so it would be nice if we could say something similar about sets, 
この数字に対する記述は正しいように思える同様に集合についても言えれば素晴らしい
so that this fact about numbers and inequalities can be seen as just a “shadow” of a more general theorem about sets and injections.
数字と不等式に対する対する事実は集合と単射に対するより一般的な定理にみえる

As hinted in the introduction, the interesting part of this problem is really the word “effectively”. 
導入に示唆したようにこの問題のもっとも興味深い部分は効果的ということです
Using the Axiom of Choice/Law of Excluded Middle makes the problem a lot easier, 
選択公理、排中律を使えばもっと簡単にとけます
but either fails to yield an actual function that we can compute with, instead merely guaranteeing the existence of such a function, 
しかし単にそのような関数の存在を保証する代わりに、実際に計算する関数の生成に失敗したり、
or gives us a function that depends on a particular ordering of A.
もしくはAの順序に依存する関数が与えられるかのどちらかである

Apparently this has been a longstanding open question, 
長い間未解決だったが
recently answered in the affirmative by Peter Doyle and Cecil Qiu in their paper Division By Four. 
最近肯定的な答えが出た
It’s a really great paper: they give some fascinating historical context for the problem, 
とても良い論文である 問題の興味深い歴史的背景を与え
and explain their algorithm (which is conceptually not all that difficult) using an intuitive analogy to a card game with certain rules. 
そして、あるルールにのっとったカードゲームという直観的なアナロジーをつかってアルゴリズムを説明する (難しいだけでなく概念的である)
(It is not a “game” in the usual sense of having winners and losers, 
通常の勝者と敗者が存在するゲームとは違う
but really just an algorithm implemented with “players” and “cards”. 
しかし、アルゴリズムにはプレーヤーとカードが登場する
In fact, you could get some friends together and actually perform this algorithm in parallel 
実際に友達と集まって平行にアルゴリズムを実行することができる
(if you have sufficiently nerdy friends).)
十分なオタク名友達がいればね
Richard Schwartz’s companion article is also great fun and easy to follow (you should read it first).
関連記事もとても面白く、理解しやすい。 最初に読んだ方がいいだろう

A Game of Thrones Cards
カードゲーム

Here’s a quick introduction to the way Doyle, Qiu, and Schwartz use a card game to formulate their algorithm. 
カードゲームで定式化されたアルゴリズムの簡単なをおこなう
(Porting this framework to use “thrones” and “claimants” instead of “spots” and “cards” is left as an exercise to the reader.)
スポットとカードの代わりに王座と原告を使った構成への移植は読者への宿題とします

The finite set N is to be thought of as a set of suits. 
有限の集合Nは組札の集合とします
The set A will correspond to a set of players, and B to a set of ranks or values (for example, Ace, 2, 3, …) 
Aの集合はプレーヤーの集合に対応し、Bは数字に対応する
In that case B x N corresponds to a deck of cards, each card having a rank and a suit; 
B x Nはカードの山に対応している、それぞれのカードは数字と絵柄を持っている
and we can think of A x N in terms of each player having in front of them a number of “spots” or “slots”, each labelled by a suit.
A x N に関してそれぞれのプレーヤーの前にそれぞれの絵柄がつけられたがスポットやスロットと呼ばれるものと考えることができる
An injection A x N -> B x N is then a particular “deal” where one card has been dealt into each of the spots in front of the players.
A x N -> B x Nの単射はプレイヤーの前のスポットにそれぞれ配ることである
(There may be some cards left over in the deck, but the fact that the function is total means every spot has a card, 
いくつかのカードは山に残っているかもしれない。しかし、全てのスポットがカードを持っていて
and the fact that it is injective is encoded in the common-sense idea that a given card cannot be in two spots at once.) 
そして、単射は同時に2つのスポットにカードが存在できないことに対応している
For example, the example function from before:
前に示した関数を示す

ここに上述の画像
(a1, True)  -> (b2, True)
(a2, False) -> (b1, False)
(a2, True)  -> (b2, False)
(a2, False) -> (b3, True)

corresponds to the following deal:
下記の分配に対応している

Spade 2 , Heart 1
Heart 1 , Spade 3

Here each column corresponds to one player’s hand, 
それぞれの行がプレーヤーの手札に対応している
and the rows correspond to suit spots (with the spade spots on top and the heart spots beneath). 
そして列が絵柄の場所に対応している(スペードが上ハートが下の場所)
We have mapped {b1, b2, b3} to the ranks A, 2, 3, and mapped T and F to Spades and Hearts respectively. 
{b1, b2, b3} と A, 2, 3が対応し、 TとFがスペードとハートにそれぞれ対応する
The spades are also highlighted in green, since later we will want to pay particular attention to what is happening with them. 
スペードは緑にハイライトし後でそれらに何が起こるのかを見ていきます
You might want to take a moment to convince yourself that the deal above really does correspond to the example function from before.
前に例に示した関数と上記の分配が本当に対応しているか少し時間ととって確認した方がいいかもしれない


A Haskell implementation
Haskellでの実装

Of course, doing everything effectively means we are really talking about computation. 
もちろん、実際に効率的に計算する
Doyle and Qiu do talk a bit about computation, 
計算について少し言及しているが、
but it’s still pretty abstract, in the sort of way that mathematicians talk about computation, 
数学者が計算について言及しているようで少し抽象的である
so I thought it would be interesting to actually implement the algorithm in Haskell. 
実際にHaskellでアルゴリズムを実装した方が興味深いだろう

The algorithm “works” for infinite sets, but only (as far as I understand) if you consider some notion of transfinite recursion. 
アルゴリズム有限の集合に対して作用するがしかし超限帰納法について考ても考えるかもしれない。
It still counts as “effective” in math-land, 
but over here in programming-land I’d like to stick to (finitely) terminating computations, 
so we will stick to finite sets A and B.
数学において効率的とみなすことができるが、プログラム的には有限としてAとBを扱うことが計算が収束するのでよいだろう

First, some extensions and imports. Nothing too controversial.
最初に拡張とimportを記述する。  異論はないだろう


We’ll need some standard machinery for type-level natural numbers. Probably all this stuff is in a library somewhere but I couldn’t be bothered to find out. Pointers welcome.
一般的な型レベル自然数が必要。すでにライブラリが損ないするかもしれなかったが探すのが面倒だった。指摘を歓迎する

Finiteness
有限

Next, a type class to represent finiteness. 
次に有限をあらわす型クラスを定義する
For our purposes, a type a is finite if we can explicitly list its elements. 
我々の目的は明示的に要素を一覧にすることが出来ればaの型は有限であるといえる
For convenience we throw in decidable equality as well, since we will usually need that in conjunction. 
簡便のために、通常一緒に必要となるので我々は同様に決定等号性を投げる 
Of course, we have to be careful: 
もちろん注意する必要がある
although we can get a list of elements for a finite type, we don’t want to depend on the ordering. 
有限の型の要素一覧を取得することは可能だが、順序に依存したくはない
We must ensure that the output of the algorithm is independent of the order of elements.
アルゴリズムの出力結果は要素の順序については独立であることを確認するべきである
This is in fact true, although somewhat nontrivial to prove formally; 
これは事実であるが正式に証明するには自明ではない
I mention some of the intuitive ideas behind the proof below.
下記証明の背景となる直観的なアイディアについてのべる

While we are at it, we give Finite instances for Fin n and for products of finite types.
Finite のインスタンスであるFin n と有限の型を定義する

Division, inductively
帰納的な分割

Now we come to the division algorithm proper. 
実際の分割アルゴリズムにたどりついた
The idea is that panGalacticPred turns an injection A x N -> B x N into an injection A x (N-1) -> B x (N-1), 
panGalacticPredの考え方は 単射 A x N -> B x N を A x (N-1) -> B x (N-1)にかえ
and then we use induction on N to repeatedly apply panGalacticPred until we get an injection A x 1 -> B x 1.
そしてpanGalacticPredを再帰的に適用しA x 1 -> B x 1を導く

In the base case, we are given an injection A x 1 -> B x 1, so we just pass a unit value in along with the A and project out the B.
最終的に、A x 1 -> B x 1 が与えられた場合、Aと一緒の単一の値を無視しBに変換する

In the inductive case, we call panGalacticPred and recurse.
それ以外の場合、再帰的にpanGalacticPredを呼ぶ


Pan-Galactic Predecessor
Pan-Galactic Predecessor (訳がわからない。。。)



And now for the real meat of the algorithm, the panGalacticPred function. 
そして今からアルゴリズムの実部分panGalacticPredを示す
The idea is that we swap outputs around until 
the function has the property that every output of the form (b,0) corresponds to an input also of the form (a,0).
そのアイディアとはｍ全ての(b,0)の型を持った出力は(a,0)という入力の型に対応するという属性を関数がもつまで交換する
That is, using the card game analogy, 
これはカードゲームを使ったアナロジーとして説明できる
every spade in play should be in the leftmost spot (the spades spot) of some player’s hand (some spades can also be in the deck). 
ゲーム中の全てのスペードはあるプレーシャーの手の中のleftmostの場所(スペードの場所)になければならない(いくつかはデッキの中にあるかもしれない)
Then simply dropping the leftmost card in everyone’s hand (and all the spades in the deck) yields a game with no spades. 
そして、みんなの手にあるleftmostのカード(と山にある全てのスペード)を捨てることでスペードの無いゲームができる
That is, we will have an injection A x {1, ..., n-1} -> B x {1, ..., n-1}.
これがA x {1, ..., n-1} -> B x {1, ..., n-1}の単射である
Taking predecessors everywhere (i.e. “hearts are the new spades”) yields the desired injection A x (N-1) -> B x (N-1).
predecessorを取り除くことで(ハートが新しいスペードになる) A x (N-1) -> B x (N-1)を実現する

We need a Finite constraint on a so that we can enumerate all possible inputs to the function, 
関数へのあらゆる入力を与えることができるようにためにaにFniteの制約が必要である
and an Eq constraint on b so that we can compare functions for extensional equality (we iterate until reaching a fixed point).
そして、外延的等しさ(不動点に達するまで繰り返す)のために関数を比較すること出来るようにbにEq制約が必要である
Note that whether two functions are extensionally equal does not depend on the order in which we enumerate their inputs, 
2つの関数が外延的に等しいとは与えられた入力の順序に依存しないというとである
so far validating my claim that nothing depends on the order of elements returned by universe.
要素の順序に依存しないという要求はuniverseによってもたらされる

We construct a function f' which is related to f by a series of swaps, 
fに関連しており、交換を繰り返すf'という関数を作成する
and has the property that it only outputs FZ when given FZ as an input.
FZが入力として与えられたとだけFZを出力するという要素を持つ
So given (a,i) we can call f' on (a, FS i) which is guaranteed to give us something of the form (b, FS j).
(a,1)が与えられたとき、f'を(a, FS i)で呼び出す。それは(b, FS j)という形を保証する
Thus it is safe to strip off the FS and return (b, j) 
なのでFSを安全に取り除き(b, j)を返す
(though the Haskell type checker most certainly does not know this, so we just have to tell it to trust us).
Haskellの型チェックはこのことが分からないので、信頼していることを伝える

To construct f' we iterate a certain transformation until reaching a fixed point. 
f'を作成するのに不動点に達するまで変換を繰り返す
For finite sets A and B this is guaranteed to terminate, though it is certainly not obvious from the Haskell code. 
有限集合のAとBにとって終端を保証されているが、Haskellのコードでは自明ではない
(Encoding this in Agda so that it is accepted by the termination checker would be a fun (?) exercise.)
Agdaでコーディングすれば終端チェックを受けることができよい勉強になるだろう

One round of the algorithm consists of two phases called “shape up” and “ship out” (to be described shortly).
アルゴリズムの1ラウンドはshape up と ship outの2つのフェーズから構成されている (これから手短にはなす)

Encoding Card Games
カードゲームの実装

Recall that a “card” is a pair of a value and a suit; we think of B as the set of values and N as the set of suits.
カードは値と絵柄の組み合わである Bは値のセットでNは絵柄のセットである

Again, there are a number of players (one for each element of A), each of which has a “hand” of cards. 
カードの手札をもった、複数のプレイヤーがいる(それぞれがAの要素)
A hand has a number of “spots” for cards, each one labelled by a different suit
手札は複数のカードのスポットをもっている スポットそれぞれは異なった絵柄が割り当てられている 
(which may not have any relation to the actual suit of the card in that position).
実際のカードの絵柄と場所には関係はないだろう

A “game” is an injective function from player spots to cards. 
ゲームはプレーヤースポットとカードに単射する関数である
Of course, the type system is not enforcing injectivity here.
もちろん、ここでは型システムは単射性を強制しない

Some utility functions. First, a function to project out the hand of a given player.
いくつかの便利関数を定義する。最初にプレイヤーに与えられた手札を投影する関数。

A function to swap two cards, yielding a bijection on cards.
二つのカードを交換し、全単射を生み出す関数

leftmost finds the leftmost card in a player’s hand which has a given suit.
leftmost は、指定された絵柄を持っているプレイヤーの手札のleftmostのカードを検索します。

Playing Rounds
プレイする

playRound abstracts out a pattern that is used by both shapeUp and shipOut. 
playRoundはshapeUpとshipOutで使われる抽象化されたパターンである
The first argument is a function which, given a hand, produces a function on cards; 
最初の引数は手札を与えるとカードを返す関数を生成する関数である
that is, based on looking at a single hand, it decides how to swap some cards around. 
これは単一の手札を見つけるためであり、どうやってカードを交換するかを決定する
playRound then applies that function to every hand, and composes together all the resulting permutations.
playRoundは、その後、すべての手札にその関数を適用し、すべての結果の順列を一緒に構成します。

Note that playRound has both Finite s and Finite p constraints, 
playRoundはFinite s とFinite pの制約を持っている
so we should think about whether the result depends on the order of elements returned by any call to universe
playRoundの結果がuniverseから返される要素の順序に依存するかどうか考えるべきである
— I claimed it does not. 
私はそうは思わない
Finite s corresponds to suits/spots, which corresponds to N in the original problem formulation. 
Finite sは絵柄/スポットに対応していてそれは元の問題のNに対応している
N explicitly has a canonical ordering, so this is not a problem. 
Nは明らかに自前の整列順序を持っているので問題はない
The Finite p constraint, on the face of it, is more problematic.
Finite p制約が抱えている問題はさらにやっかいである
We will have to think carefully about each of the rounds implemented in terms of playRound and make sure they do not depend on the order of players. 
playRoundの各ラウンドの実装に関して注意深く考えなければいけない そしてプレイヤーの順序に依存してはいけないことを確かめなければいけない
Put another way, it should be possible for all the players to take their turn simultaneously.
言い換えれば、すべてのプレイヤーが同時に処理することが可能でなければいけない

Shape Up and Ship Out
shap up と ship out

Finally, we can describe the “shape up” and “ship out” phases, beginning with “shape up”. 
最後にshape upとship outフェイズについて記述する。最初にshape upについて。
A “bad” card is defined as one having the lowest suit; 
手持ちのもっとも小さい絵柄を悪いカードと定義する
make sure every hand with any bad cards has one in the leftmost spot 
全ての手札の中から悪いカードがleftmostの場所にあるようにする
(by swapping the leftmost bad card with the card in the leftmost spot, if necessary).
必要ならば、leftmostの場所のカードと悪いカードを交換する

And now for the “ship out” phase. 
ship outフェーズについて
Send any “bad” cards not in the leftmost spot somewhere else, by swapping with a replacement, namely, 
leftmostに存在しない悪いカードを何処かに送る すなわち別のものと交換する
the card whose suit is the same as the suit of the spot, and whose value is the same as the value of the bad card in the leftmost spot.
leftmostにある悪いカードと同じ数字のカードとそのカードがあるべき場所のカードを置き換える
The point is that bad cards in the leftmost spot are OK, since we will eventually just ignore the leftmost spot. 
ポイントは、leftmostに悪いカードがあることは問題ない。やがてleftmostの場所は無視する
So we have to keep shipping out bad cards not in the leftmost spot until they all end up in the leftmost spot. 
leftmostにない悪いカードが無くなるまで悪いカードをshipping out する
For some intuition as to why this is guaranteed to terminate, consult Schwartz; 
なぜ終了することがが保証されているがという直感はSchwartzに相談してくれ
note that columns tend to acquire more and more cards that have the same rank as a spade in the top spot (which never moves).
カラムは上の場所にある同じランクのスペードのカードを次々と手に入れるようになる。それは決して動かない

And that’s it! Note that both shapeUp and shipOut are implemented by composing a bunch of swaps; 
これでおわり。shapeUpとshipOutの両方とも交換の集まりの構成から実装されていることに気をつけなければならない
in fact, in both cases, all the swaps commute, so the order in which they are composed does not matter. 
実際両方の場合で全ての交換されるので構成するものの順序は重要ではない
(For proof, see Schwartz.) Thus, the result is independent of the order of the players (i.e. the set A).
なのでプレーヤーの順序と結果は独立である




